import os
import re
import pyautogui
import pygetwindow as gw
import time
import json
import shutil
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException, ElementClickInterceptedException
from webdriver_manager.chrome import ChromeDriverManager
from supabase import create_client, Client
from datetime import datetime, timedelta

# Configura√ß√µes do Supabase
SUPABASE_URL = "https://uvgznbifmwocdpkbuumv.supabase.co"  # Substitua pelo seu URL do Supabase
SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV2Z3puYmlmbXdvY2Rwa2J1dW12Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzc1NDgzMzksImV4cCI6MjA1MzEyNDMzOX0.aqwOrYMELMyXtIfph9Val_qq72Q80jQ3hIRCRaOgQbQ"  # Substitua pela sua API Key
TABLE_NAME = "nips_abertas"  # Nome correto da tabela
COLUMN_NAME = "demanda"  # Nome correto da coluna

# Configura√ß√£o da URL da ANS e credenciais
URL_LOGIN = "https://www2.ans.gov.br/nip_operadora/?target=3396a8b22ba2f5ff5500f7672a11a803ea7189ab0141d68f5148553f4beab2c6"
USUARIO = "57862897889"
SENHA = "@Blue2025"

# Criar cliente do Supabase
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# Configura√ß√µes globais
TEMPO_ESPERA = 15  # segundos
SLEEP_TIME = 1800  # 30 minutos

def salvar_log(mensagem):
    with open("log_V3.txt", "a", encoding="utf-8") as arquivo_log:
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        arquivo_log.write(f"{timestamp} - {mensagem}\n")

def criar_diretorio_downloads(id_atual, pasta_base="C:\\Users\\Blue Suporte\\Documents\\criacaoDeDiretorios"):
    """Cria um diret√≥rio exclusivo para os arquivos do ID atual e retorna o caminho completo."""
    caminho_id = os.path.join(pasta_base, str(id_atual))
    if not os.path.exists(caminho_id):
        os.makedirs(caminho_id)
        salvar_log(f"[INFO] Diret√≥rio criado para ID {id_atual}: {caminho_id}")
    return caminho_id

def iniciar_navegador():
    options = webdriver.ChromeOptions()
    options.add_argument("--start-maximized")
    options.add_argument("--kiosk-printing")  # Habilita impress√£o silenciosa para PDFs
    options.add_argument("--incognito")

    prefs = {
        "printing.print_preview_sticky_settings.appState": json.dumps({
            "recentDestinations": [{
                "id": "Save as PDF",
                "origin": "local",
                "account": ""
            }],
            "selectedDestinationId": "Save as PDF",
            "version": 2 
        }),
        "savefile.default_directory": "C:\\Users\\Blue Suporte\\Downloads",  # Para arquivos de impress√£o
        "download.default_directory": "C:\\Users\\Blue Suporte\\Downloads",  # Para arquivos adicionais
        "download.prompt_for_download": False,  # Impede a janela "Salvar como"
        "download.directory_upgrade": True,
        "safebrowsing.enabled": True,
        "plugins.always_open_pdf_externally": True,  # PDF ser√° baixado diretamente (n√£o aberto no navegador)
        "download.extensions_to_open": ""  # ‚õî Evita que qualquer arquivo seja aberto automaticamente
    }

    options.add_experimental_option("prefs", prefs)

    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)

    # Garante comportamento correto para downloads autom√°ticos via CDP
    driver.execute_cdp_cmd("Page.setDownloadBehavior", {
        "behavior": "allow",
        "downloadPath": "C:\\Users\\Blue Suporte\\Downloads"
    })

    return driver

def configurar_downloads_para_id(driver, caminho_id):
    """Configura o navegador para salvar os downloads no diret√≥rio do ID, sem janelas."""
    salvar_log(f"[INFO] Configurando downloads autom√°ticos para: {caminho_id}")
    try:
        driver.execute_cdp_cmd("Page.setDownloadBehavior", {
            "behavior": "allow",
            "downloadPath": caminho_id
        })
        salvar_log(f"[INFO] Configura√ß√£o de download autom√°tico aplicada com sucesso.")
    except Exception as e:
        salvar_log(f"[ERRO] Falha ao configurar download autom√°tico: {str(e)}")

def realizar_login(driver, max_tentativas=3):
    for tentativa in range(max_tentativas):
        try:
            driver.get(URL_LOGIN)
            WebDriverWait(driver, TEMPO_ESPERA).until(
                EC.presence_of_element_located((By.ID, "input-mask"))
            ).send_keys(USUARIO)
            driver.find_element(By.ID, "mod-login-password").send_keys(SENHA)
            driver.find_element(By.ID, "botao").click()
            WebDriverWait(driver, TEMPO_ESPERA).until(EC.url_changes(URL_LOGIN))
            salvar_log("[INFO] Login realizado com sucesso.")
            return True  # Login bem-sucedido
        except Exception as e:
            salvar_log(f"[ERRO] Tentativa {tentativa + 1} de login falhou: {str(e)}")
            if tentativa < max_tentativas - 1:
                time.sleep(5)  # Aguarda antes de tentar novamente
            else:
                salvar_log("[ERRO] Todas as tentativas de login falharam.")
                return False

def testar_conexao_supabase():
    """Testa a conex√£o com o Supabase e verifica se a tabela est√° acess√≠vel."""
    try:
        salvar_log("[INFO] Testando conex√£o com o Supabase...")
        response = supabase.table("nips-abertas").select("*").limit(1).execute()

        if hasattr(response, "error") and response.error:
            salvar_log(f"[ERRO] Falha ao conectar ao Supabase: {response.error}")
            return False

        salvar_log("[SUCESSO] Conex√£o com Supabase estabelecida e tabela acess√≠vel.")
        return True
    except Exception as e:
        salvar_log(f"[ERRO] Exce√ß√£o ao testar conex√£o com Supabase: {str(e)}")
        return False

def carregar_ids_processados():
    try:
        response = supabase.table(TABLE_NAME).select("demanda").execute()
        ids = {item["demanda"] for item in response.data if item["demanda"]} if response.data else set()  # Pegando a coluna correta
        salvar_log(f"[INFO] IDs carregados do banco de dados: {ids}")
        return ids
    except Exception as e:
        salvar_log(f"[ERRO] Falha ao carregar IDs do banco: {str(e)}")
        return set()
  
def reiniciar_conexao_supabase():
    """Reinicia a conex√£o com o Supabase para evitar cache de sess√µes antigas."""
    global supabase
    salvar_log("[INFO] Reiniciando conex√£o com o Supabase para limpar cache...")
    supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

def aguardar_proxima_execucao():
    """Aguarda o tempo de sleep definido e reinicia a conex√£o com Supabase para evitar cache."""
    salvar_log(f"[INFO] Entrando em sleep de {SLEEP_TIME} segundos antes da pr√≥xima tentativa.")
    time.sleep(SLEEP_TIME)
    reiniciar_conexao_supabase()

def capturar_ids_html(driver):
    """Captura apenas os IDs num√©ricos da tabela HTML mantendo a ordem."""
    try:
        wait = WebDriverWait(driver, 15)
        celulas = wait.until(
            EC.presence_of_all_elements_located(
                (By.XPATH, "//tbody[contains(@id, 'tbDemandaAguardandoResposta_data')]//td[@role='gridcell' and text()[number()=number()]]")
            )
        )
        ids = [td.text.strip() for td in celulas if td.text.strip().isdigit()]

        salvar_log(f"[INFO] IDs capturados no HTML: {ids}")
        return ids

    except TimeoutException:
        salvar_log("[ERRO] Timeout ao capturar IDs do HTML.")
        return []

def salvar_dados_no_banco(dados_linha):
    """Salva corretamente os dados no Supabase, garantindo que a estrutura original funcione."""
    try:
        if not isinstance(dados_linha, dict):
            salvar_log(f"[ERRO] O formato dos dados est√° incorreto! Esperado um dicion√°rio, recebido: {type(dados_linha)}")
            return False

        # Converte `datetime` para string antes de salvar
        if isinstance(dados_linha.get("data_notificacao"), datetime):
            dados_linha["data_notificacao"] = dados_linha["data_notificacao"].strftime("%Y-%m-%d %H:%M:%S")

        response = supabase.table(TABLE_NAME).insert(dados_linha).execute()

        if response.data:
            id_gerado = response.data[0].get('id')
            salvar_log(f"[INFO] Dados salvos com sucesso no banco. ID √∫nico gerado: {id_gerado}")
            return id_gerado
        else:
            salvar_log(f"[ERRO] Falha ao salvar os dados no banco. Resposta: {response}")
            return False

    except Exception as e:
        salvar_log(f"[ERRO] Exce√ß√£o ao salvar dados no banco: {str(e)}")
        return False

def capturar_dados_linha(driver, id_atual, max_tentativas=3):
    for tentativa in range(max_tentativas):
        try:
            linha_xpath = f"//td[text()='{id_atual}']/parent::tr"
            linha_elemento = WebDriverWait(driver, TEMPO_ESPERA).until(
                EC.presence_of_element_located((By.XPATH, linha_xpath))
            )
            
            colunas = linha_elemento.find_elements(By.TAG_NAME, "td")
            if len(colunas) < 7:
                salvar_log(f"[ERRO] ID {id_atual}: linha com colunas insuficientes ({len(colunas)}).")
                return None

            # üü¢ Mesma l√≥gica de convers√£o de campos:
            data_notificacao = colunas[0].text.strip()
            demanda = colunas[1].text.strip()
            protocolo = colunas[2].text.strip()
            beneficiario = colunas[3].text.strip()
            prazo = colunas[4].text.strip()
            respondido = colunas[5].text.strip()
            natureza = colunas[6].text.strip()

            try:
                data_notificacao = datetime.strptime(data_notificacao, "%d/%m/%Y %H:%M:%S")
            except:
                data_notificacao = None

            try:
                prazo = int(prazo.split()[0]) if "dias" in prazo else None
            except:
                prazo = None

            respondido = respondido.replace("\n", " ")[:10] if respondido else None

            dados = {
                "demanda": demanda,
                "data_notificacao": data_notificacao,
                "protocolo": protocolo,
                "beneficiario": beneficiario,
                "cpf": None,
                "descricao_demanda": None,
                "prazo": prazo,
                "respondido": respondido,
                "natureza": natureza
            }

            salvar_log(f"[INFO] Dados capturados corretamente para o ID {id_atual}: {dados}")
            return dados

        except StaleElementReferenceException:
            salvar_log(f"[WARNING] Tentativa {tentativa+1}/{max_tentativas} falhou por StaleElement para ID {id_atual}. Tentando novamente...")
            time.sleep(2)
        except Exception as e:
            salvar_log(f"[ERRO] Tentativa {tentativa+1}: Falha ao capturar dados da linha do ID {id_atual}: {e}")
            if tentativa == max_tentativas - 1:
                return None
            time.sleep(2)

def clicar_botao(driver, xpath):
    tentativas = 3
    for tentativa in range(tentativas):
        try:
            botao = WebDriverWait(driver, TEMPO_ESPERA).until(
                EC.element_to_be_clickable((By.XPATH, xpath))
            )
            driver.execute_script("arguments[0].scrollIntoView();", botao)
            time.sleep(1)
            botao.click()
            return True
        except StaleElementReferenceException:
            salvar_log(f"[ERRO] Tentativa {tentativa+1}: Elemento ficou obsoleto (stale). Tentando novamente...")
            time.sleep(2)
        except TimeoutException:
            salvar_log(f"[ERRO] Tentativa {tentativa+1}: Timeout ao clicar no bot√£o. Verifique o XPath.")
            return False
        except ElementClickInterceptedException:
            salvar_log(f"[ERRO] Tentativa {tentativa+1}: Outro elemento interceptou o clique. Tentando novamente...")
            driver.execute_script("window.scrollBy(0,100);")
            time.sleep(1)
        except Exception as e:
            salvar_log(f"[ERRO] Tentativa {tentativa+1}: Erro inesperado ao clicar no bot√£o: {str(e)}")
            return False
    return False

def clicar_botao_visualizar(driver, id_atual):
    """
    Fun√ß√£o espec√≠fica para rolar e clicar no bot√£o Visualizar.
    Retorna True se conseguiu clicar, False caso contr√°rio.
    """
    try:
        salvar_log(f"[INFO] Tentando encontrar e clicar no bot√£o Visualizar para o ID {id_atual}")
        
        # Espera um tempo extra para garantir que o bot√£o carregou
        time.sleep(2)
        
        # Rolar a p√°gina um pouco mais para garantir que o bot√£o fique vis√≠vel
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(2)

        visualizar_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Visualizar']]"

        botao_visualizar = WebDriverWait(driver, TEMPO_ESPERA).until(
            EC.element_to_be_clickable((By.XPATH, visualizar_xpath))
        )

        driver.execute_script("arguments[0].scrollIntoView();", botao_visualizar)
        time.sleep(1)
        botao_visualizar.click()

        salvar_log(f"[INFO] Bot√£o Visualizar clicado com sucesso para o ID {id_atual}")
        return True
    except TimeoutException:
        salvar_log(f"[ERRO] Timeout ao clicar no bot√£o Visualizar para o ID {id_atual}. Verifique se o bot√£o est√° presente.")
        return False
    except StaleElementReferenceException:
        salvar_log(f"[ERRO] O bot√£o Visualizar ficou indispon√≠vel repentinamente. Tentando novamente...")
        time.sleep(2)
        return clicar_botao_visualizar(driver, id_atual)  # Recurs√£o para tentar clicar novamente
    except Exception as e:
        salvar_log(f"[ERRO] Erro inesperado ao clicar no bot√£o Visualizar para o ID {id_atual}: {str(e)}")
        return False

def clicar_botao_salvar_pdf(driver):
    """Aguarda a janela de impress√£o e confirma o salvamento como PDF."""
    try:
        salvar_log("[INFO] Aguardando janela de impress√£o...")
        time.sleep(2)  # Pequena espera para garantir que a janela seja carregada
        
        # Enviar comando para confirmar o salvamento autom√°tico
        driver.execute_script("window.print();")
        salvar_log("[INFO] Documento salvo como PDF automaticamente.")
        return True
    except Exception as e:
        salvar_log(f"[ERRO] Falha ao salvar o documento PDF: {str(e)}")
        return False

def mover_arquivos_para_diretorio(caminho_downloads, caminho_destino):
    """
    Move somente os arquivos do diret√≥rio de downloads para o diret√≥rio de destino.
    Ignora subpastas como 'Downloads' que podem estar dentro por engano.
    """
    try:
        salvar_log(f"[INFO] Movendo arquivos de {caminho_downloads} para {caminho_destino}")

        arquivos = [
            f for f in os.listdir(caminho_downloads)
            if os.path.isfile(os.path.join(caminho_downloads, f))
        ]

        if not arquivos:
            salvar_log("[INFO] Nenhum arquivo encontrado no diret√≥rio de downloads.")
            return

        for arquivo in arquivos:
            caminho_origem = os.path.join(caminho_downloads, arquivo)
            caminho_destino_arquivo = os.path.join(caminho_destino, arquivo)

            shutil.move(caminho_origem, caminho_destino_arquivo)
            salvar_log(f"[INFO] Arquivo {arquivo} movido com sucesso para {caminho_destino}")

        salvar_log(f"[INFO] Todos os arquivos foram movidos para {caminho_destino}")

    except Exception as e:
        salvar_log(f"[ERRO] Falha ao mover arquivos: {e}")

def aplicar_filtro_data(driver):
    """Aplica o filtro de data na interface com um per√≠odo fixo entre 01/12/2024 e 31/12/2024."""
    try:
        salvar_log("[INFO] Aplicando filtro de datas.")
        wait = WebDriverWait(driver, TEMPO_ESPERA)

        hoje = datetime.now().strftime("%d/%m/%Y")
        ontem = (datetime.now() - timedelta(days=1)).strftime("%d/%m/%Y")

        # Aguardar at√© que os campos de data e o bot√£o de busca estejam vis√≠veis
        salvar_log("[INFO] Aguardando campos de data e bot√£o de busca...")
        campo_data_inicial = wait.until(EC.visibility_of_element_located((By.ID, "formContent:dtInicio_input")))
        campo_data_final = wait.until(EC.visibility_of_element_located((By.ID, "formContent:dtFim_input")))
        botao_buscar = wait.until(EC.element_to_be_clickable((By.ID, "formContent:j_idt82")))

        # Limpar e preencher os campos de data com as datas fixas
        salvar_log("[INFO] Preenchendo campos de data...")
        campo_data_inicial.clear()
        campo_data_inicial.send_keys(ontem)
        campo_data_final.clear()
        campo_data_final.send_keys(hoje)

        # Clicar no bot√£o de busca
        salvar_log("[INFO] Clicando no bot√£o de busca...")
        botao_buscar.click()

        # Aguardar at√© que a tabela de resultados esteja vis√≠vel
        salvar_log("[INFO] Aguardando tabela de resultados...")
        wait.until(EC.presence_of_element_located((By.ID, "formContent:j_idt85:tbDemandaAguardandoResposta_data")))
        salvar_log("Filtro de data aplicado com sucesso.")
        return True

    except StaleElementReferenceException:
        salvar_log("[ERRO] Elemento n√£o est√° mais presente na p√°gina. Tentando novamente ap√≥s recarregar a p√°gina.")
        driver.refresh()
        time.sleep(5)  # Aguardar um pouco antes de tentar novamente
        return aplicar_filtro_data(driver)

    except TimeoutException:
        salvar_log("[ERRO] Timeout ao aguardar elementos da p√°gina. Tentando novamente ap√≥s recarregar a p√°gina.")
        driver.refresh()
        time.sleep(5)  # Aguardar um pouco antes de tentar novamente
        return aplicar_filtro_data(driver)

    except Exception as e:
        salvar_log(f"[ERRO] Falha ao aplicar filtro de data: {str(e)}")
        return False

def navegar_paginacao(driver):
    """Navega para a pr√≥xima p√°gina se dispon√≠vel, sen√£o retorna False para indicar que n√£o h√° mais p√°ginas."""
    try:
        botao_proxima = WebDriverWait(driver, 5).until(
            EC.presence_of_element_located((By.XPATH, "//span[contains(@class, 'ui-paginator-next') and not(contains(@class, 'ui-state-disabled'))]"))
        )
        botao_proxima.click()
        salvar_log("[INFO] Avan√ßando para a pr√≥xima p√°gina de resultados...")
        time.sleep(3)  # Tempo para carregar a pr√≥xima p√°gina
        return True
    except TimeoutException:
        salvar_log("[INFO] Nenhuma pr√≥xima p√°gina dispon√≠vel.")
        return False

def capturar_total_registros(driver):
    """ Captura o n√∫mero total de registros da p√°gina para determinar o momento de ativar o sleep time. """
    try:
        elemento_paginacao = driver.find_element(By.CLASS_NAME, "ui-paginator-current")
        texto_paginacao = elemento_paginacao.text  # Exemplo: "Registros: 1 a 10 de 14"

        # Extrai os n√∫meros do texto
        numeros = list(map(int, re.findall(r'\d+', texto_paginacao)))

        if len(numeros) == 3:
            inicio, fim, total = numeros
            salvar_log(f"[INFO] P√°gina atual exibe registros de {inicio} a {fim} de um total de {total}")
            return inicio, fim, total
        else:
            salvar_log("[ERRO] Formato inesperado na pagina√ß√£o. N√£o foi poss√≠vel extrair os valores.")
            return None, None, None

    except Exception as e:
        salvar_log(f"[ERRO] Falha ao capturar total de registros: {str(e)}")
        return None, None, None

def iniciar_download(driver, id_atual, caminho_id):
    """Inicia o download do PDF imprimindo a p√°gina e garantindo que o arquivo seja salvo corretamente."""
    try:
        salvar_log(f"[INFO] Clicando no bot√£o Imprimir para ID {id_atual}...")

        imprimir_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Imprimir']]"
        if clicar_botao(driver, imprimir_xpath):
            salvar_log("[INFO] Bot√£o Imprimir clicado. Aguardando a janela de salvamento...")
            time.sleep(10)  # Aguardar mais tempo para que a janela e o documento carreguem completamente
        else:
            salvar_log("[ERRO] Bot√£o Imprimir n√£o encontrado.")
            return False

        # üîπ **Aguardar a janela de impress√£o estar carregada**
        salvar_log("[INFO] Aguardando a janela de impress√£o renderizar o PDF...")
        time.sleep(5)  # Aguarda o carregamento do conte√∫do

        # üîπ **Garantir que o campo do nome do arquivo est√° ativo**
        salvar_log("[INFO] Garantindo que o campo do nome do arquivo est√° ativo...")
        pyautogui.click(500, 400)  # Clique no campo de nome do arquivo
        time.sleep(1)

        # üîπ **Definir o caminho e manter o nome original do arquivo**
        caminho_arquivo = os.path.join(caminho_id)
        salvar_log(f"[INFO] Caminho digitado na janela: {caminho_arquivo}")

        pyautogui.write(caminho_arquivo, interval=0.1)  # Digita devagar para evitar erros
        time.sleep(1)
        pyautogui.press("enter")  # Pressiona Enter para salvar

        salvar_log(f"[INFO] PDF salvo com sucesso: {caminho_arquivo}")
        return True

    except Exception as e:
        salvar_log(f"[ERRO] Falha ao salvar o PDF: {str(e)}")
        return False

def aguardar_download(pasta_downloads, timeout=60):
    """Aguarda todos os downloads (PDF ou outros arquivos) serem conclu√≠dos."""
    salvar_log("[INFO] Aguardando finaliza√ß√£o de downloads...")

    tempo_inicial = time.time()
    while time.time() - tempo_inicial < timeout:
        arquivos = os.listdir(pasta_downloads)
        arquivos_temp = [f for f in arquivos if f.endswith(".crdownload") or f.endswith(".tmp")]

        if not arquivos_temp:
            salvar_log("[INFO] Todos os downloads foram finalizados.")
            return arquivos  # Retorna lista dos arquivos baixados

        time.sleep(2)

    salvar_log("[ERRO] Timeout ao aguardar downloads.")
    return []

def baixar_arquivos(driver, id_nip, caminho_download):
    """
    Fun√ß√£o para baixar todos os arquivos dispon√≠veis para um determinado ID.
    :param driver: Inst√¢ncia do WebDriver.
    :param id_nip: ID do processo que est√° sendo processado.
    :param caminho_download: Diret√≥rio onde os arquivos devem ser salvos.
    """
    try:
        salvar_log(f"[INFO] Iniciando download de arquivos para o ID {id_nip}")

        if not os.path.exists(caminho_download):
            os.makedirs(caminho_download)
            salvar_log(f"[INFO] Diret√≥rio criado para ID {id_nip}: {caminho_download}")
        else:
            salvar_log(f"[INFO] Diret√≥rio j√° existe para ID {id_nip}: {caminho_download}")

        xpath_download = "//button[.//span[text()='Download']]"

        while True:
            try:
                botoes_download = WebDriverWait(driver, 10).until(
                    EC.presence_of_all_elements_located((By.XPATH, xpath_download))
                )
            except TimeoutException:
                salvar_log("[INFO] Nenhum bot√£o de download encontrado nesta p√°gina.")
                break

            salvar_log(f"[INFO] Encontrados {len(botoes_download)} arquivos para download nesta p√°gina.")

            for i in range(len(botoes_download)):
                try:
                    salvar_log(f"[INFO] Clicando no bot√£o de download {i+1}/{len(botoes_download)}...")
                    botoes_atualizados = driver.find_elements(By.XPATH, xpath_download)
                    if i < len(botoes_atualizados):
                        driver.execute_script("arguments[0].click();", botoes_atualizados[i])
                        time.sleep(3)  # Aguarda abertura da janela
                        salvar_log("[INFO] Tentando ativar a janela 'Salvar como'...")
                        pyautogui.press("enter")
                        time.sleep(1)
                    else:
                        salvar_log(f"[ERRO] Bot√£o {i} n√£o encontrado ap√≥s reatualiza√ß√£o.")
                except StaleElementReferenceException:
                    salvar_log("[ERRO] Elemento ficou obsoleto. Ignorando e continuando.")
                except Exception as e:
                    salvar_log(f"[ERRO] Falha ao clicar no bot√£o de download {i+1}: {e}")

            if not navegar_paginacao(driver):
                salvar_log(f"[INFO] Nenhuma pr√≥xima p√°gina de arquivos dispon√≠vel.")
                break

        salvar_log(f"[INFO] Todos os downloads finalizados para o ID {id_nip}")

    except Exception as e:
        salvar_log(f"[ERRO] Erro inesperado ao baixar arquivos para ID {id_nip}: {e}")

def fluxo_processamento_id(driver, id_atual):
    tentativas = 3
    for tentativa in range(tentativas):
        try:
            salvar_log(f"[INFO] Iniciando processamento do ID {id_atual}")
            caminho_id = criar_diretorio_downloads(id_atual)
            configurar_downloads_para_id(driver, caminho_id)

            dados_linha = capturar_dados_linha(driver, id_atual)
            if not dados_linha:
                salvar_log(f"[ERRO] N√£o foi poss√≠vel capturar os dados da linha para o ID {id_atual}. Pulando para o pr√≥ximo.")
                return False

            detalhes_xpath = f"//tr[td[contains(text(), '{id_atual}')]]//button[contains(@id, 'j_idt') and .//span[text()='Detalhes']]"
            if clicar_botao(driver, detalhes_xpath):
                salvar_log(f"[INFO] Bot√£o Detalhes clicado para o ID {id_atual}")
                time.sleep(2)
            else:
                salvar_log(f"[ERRO] Bot√£o Detalhes n√£o encontrado para o ID {id_atual}")
                return False

            visualizar_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Visualizar']]"
            if clicar_botao(driver, visualizar_xpath):
                salvar_log(f"[INFO] Bot√£o Visualizar clicado para o ID {id_atual}")
                time.sleep(2)
            else:
                salvar_log(f"[ERRO] Bot√£o Visualizar n√£o encontrado para o ID {id_atual}")
                return False

            imprimir_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Imprimir']]"
            if clicar_botao(driver, imprimir_xpath):
                salvar_log(f"[INFO] Bot√£o Imprimir clicado para o ID {id_atual}")
                salvar_log("[INFO] Aguardando download do PDF gerado pela impress√£o...")
                aguardar_download("C:\\Users\\Blue Suporte\\Downloads")
            else:
                salvar_log(f"[ERRO] Bot√£o Imprimir n√£o encontrado para o ID {id_atual}")
                return False

            fechar_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Fechar']]"
            if clicar_botao(driver, fechar_xpath):
                salvar_log(f"[INFO] Bot√£o Fechar clicado para o ID {id_atual}")
                time.sleep(2)
            else:
                salvar_log(f"[ERRO] Bot√£o Fechar n√£o encontrado para o ID {id_atual}")
                return False

            salvar_log(f"[INFO] Iniciando download de arquivos para o ID {id_atual}")
            baixar_arquivos(driver, id_atual, caminho_id)

            salvar_log(f"[INFO] Aguardando finaliza√ß√£o de todos os downloads para o ID {id_atual}")
            aguardar_download("C:\\Users\\Blue Suporte\\Downloads")

            salvar_log(f"[INFO] Movendo arquivos de C:\\Users\\Blue Suporte\\Downloads para {caminho_id}")
            mover_arquivos_para_diretorio("C:\\Users\\Blue Suporte\\Downloads", caminho_id)

            salvar_log(f"[DEBUG] Tentando salvar os seguintes dados no banco: {dados_linha}")
            if salvar_dados_no_banco(dados_linha):
                salvar_log(f"[INFO] ID {id_atual} salvo no banco de dados ap√≥s processamento.")
            else:
                salvar_log(f"[ERRO] Falha ao salvar o ID {id_atual} no banco.")

            if not retornar_pagina_inicial(driver):
                salvar_log(f"[ERRO] Falha ao retornar √† p√°gina inicial ap√≥s o ID {id_atual}. Recarregando...")
                driver.refresh()
                time.sleep(5)

            salvar_log(f"[SUCESSO] Fluxo conclu√≠do para o ID {id_atual}")
            return True

        except StaleElementReferenceException:
            salvar_log(f"[ERRO] Elemento n√£o est√° mais presente na p√°gina. Tentando novamente ({tentativa + 1}/{tentativas})...")
            driver.refresh()
            time.sleep(5)
        except Exception as e:
            salvar_log(f"[ERRO] Falha ao processar ID {id_atual}: {type(e).__name__} - {str(e)}")
            if tentativa < tentativas - 1:
                salvar_log(f"[INFO] Tentando novamente ({tentativa + 1}/{tentativas})...")
                time.sleep(5)
            else:
                salvar_log(f"[ERRO] Todas as tentativas falharam para o ID {id_atual}.")
                return False

def retornar_pagina_inicial(driver, max_tentativas=3):
    for tentativa in range(max_tentativas):
        try:
            salvar_log("[INFO] Tentando retornar √† p√°gina inicial...")

            botao_voltar_xpath = "//button[contains(@id, 'j_idt') and .//span[text()='Voltar']]"
            if clicar_botao(driver, botao_voltar_xpath):
                salvar_log("[INFO] Bot√£o Voltar clicado com sucesso.")
                time.sleep(3)
                return True

            salvar_log(f"[ERRO] Tentativa {tentativa + 1}: Bot√£o Voltar n√£o encontrado. Tentando novamente...")

        except Exception as e:
            salvar_log(f"[ERRO] Tentativa {tentativa + 1}: Exce√ß√£o ao tentar retornar √† p√°gina inicial: {str(e)}")

        if tentativa < max_tentativas - 1:
            time.sleep(5)
            driver.refresh()  # Se falhar, recarrega a p√°gina e tenta de novo

    salvar_log("[ERRO] Todas as tentativas falharam ao retornar √† p√°gina inicial.")
    return False

def verificar_pagina_inicial(driver):
    """ Confirma se a p√°gina inicial foi carregada ap√≥s voltar. """
    try:
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//table[contains(@id, 'tbDemandaAguardandoResposta_data')]"))
        )
        return True
    except TimeoutException:
        return False

def verificar_sessao_expirada(driver):
    """Verifica se a sess√£o ainda est√° ativa ou se a p√°gina de login foi carregada."""
    try:
        WebDriverWait(driver, 5).until(
            EC.presence_of_element_located((By.ID, "input-mask"))  # Campo de login
        )
        return True  # Sess√£o expirada
    except TimeoutException:
        return False  # Sess√£o ainda est√° ativa

def executar_fluxo_principal(driver):
    """
    Executa o fluxo principal e finaliza a execu√ß√£o desta rodada quando:
      - Todos os registros foram processados;
      - N√£o h√° pr√≥xima p√°gina;
      - Ou os IDs j√° foram processados.
    """
    while True:
        if not aplicar_filtro_data(driver):
            salvar_log("[ERRO] Falha ao aplicar o filtro de datas. Recarregando a p√°gina...")
            driver.refresh()
            time.sleep(5)
            continue

        ids_processados = carregar_ids_processados()
        todos_ids_processados = True

        while True:  # Loop para percorrer todas as p√°ginas dispon√≠veis
            time.sleep(2)
            ids_pagina = capturar_ids_html(driver)

            if not ids_pagina:
                salvar_log("[INFO] Nenhum ID encontrado na p√°gina.")
                break  # Finaliza o loop de pagina√ß√£o

            # Filtra apenas IDs nas posi√ß√µes pares que ainda n√£o foram processados
            ids_a_processar = [
                id_html for index, id_html in enumerate(ids_pagina)
                if index % 2 == 0 and id_html not in ids_processados
            ]

            if not ids_a_processar:
                salvar_log("[INFO] Todos os IDs desta p√°gina j√° foram processados.")
                todos_ids_processados = True
            else:
                todos_ids_processados = False
                for id_atual in ids_a_processar:
                    salvar_log(f"[INFO] Iniciando processamento do ID {id_atual}")
                    if fluxo_processamento_id(driver, id_atual):
                        salvar_log(f"[INFO] ID {id_atual} processado com sucesso.")
                    else:
                        salvar_log(f"[ERRO] Falha ao processar o ID {id_atual}. Continuando...")

            # Captura a pagina√ß√£o para decidir se h√° mais registros
            inicio, fim, total = capturar_total_registros(driver)
            if inicio and fim and total:
                if fim >= total:
                    salvar_log("[INFO] Todos os registros j√° foram processados nesta rodada.")
                    return  # Encerra a execu√ß√£o deste fluxo

            # Tenta navegar para a pr√≥xima p√°gina; se n√£o houver, encerra
            if not navegar_paginacao(driver):
                salvar_log("[INFO] Nenhuma pr√≥xima p√°gina dispon√≠vel nesta rodada.")
                return  # Encerra a execu√ß√£o deste fluxo

        if todos_ids_processados:
            salvar_log("[INFO] Todos os IDs j√° foram processados nesta rodada.")
            return  # Encerra a execu√ß√£o deste fluxo

def main():
    salvar_log("[INFO] Iniciando nova rodada do RPA.")

    # Valida conex√£o com o Supabase antes de tudo
    if not testar_conexao_supabase():
        salvar_log(f"[WARNING] Conex√£o com o Supabase falhou. Aguardando {SLEEP_TIME} segundos antes de tentar novamente.")
        time.sleep(SLEEP_TIME)
        return None

    driver = iniciar_navegador()

    if not driver:
        salvar_log("[ERRO] Falha ao iniciar o navegador.")
        return None

    try:
        if not realizar_login(driver):
            salvar_log("[ERRO] Falha no login. Encerrando esta rodada.")
            return driver  # Retorna driver para ser encerrado
        time.sleep(3)
        executar_fluxo_principal(driver)
    except Exception as e:
        salvar_log(f"[FATAL] Erro inesperado durante execu√ß√£o do main(): {type(e).__name__} - {str(e)}")
        return driver

    return driver

if __name__ == "__main__":
    while True:
        driver = None
        try:
            salvar_log("[INFO][MAIN LOOP] Iniciando ciclo do RPA com autorrecupera√ß√£o.")
            driver = main()
        except Exception as e:
            salvar_log(f"[FATAL] Erro inesperado fora do fluxo controlado: {type(e).__name__} - {str(e)}")
        
        if driver:
            try:
                driver.quit()
                salvar_log("[INFO] Navegador encerrado com sucesso ap√≥s a rodada.")
            except Exception as e:
                salvar_log(f"[WARNING] Falha ao encerrar o navegador: {type(e).__name__} - {str(e)}")

        salvar_log(f"[INFO][RECOVERY] Aguardando {SLEEP_TIME} segundos antes de reiniciar o RPA.")
        time.sleep(SLEEP_TIME)
